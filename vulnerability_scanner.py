import requests
from bs4 import BeautifulSoup
from PyQt5.QtCore import QObject, pyqtSignal
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service as ChromeService


class VulnerabilityScanner(QObject):
    progress_signal = pyqtSignal(int)

    def __init__(self, url, log_callback):
        super().__init__()
        self.url = url
        self.log = log_callback
        self.num_checks = 5
        self.detailed_logs = {'sql':[],'xss':[],'csrf':[],'dir':[],'ver':[]}
        self.summaries = {'sql':[],'xss':[],'csrf':[],'dir':[],'ver':[]}
        self.success = True  # Initialize success flag

    def scan(self):
        completed_checks = 0
        checks = [
            ('sql', self.check_sql_injection),
            ('xss', self.check_xss),
            ('csrf', self.check_csrf),
            ('dir', self.check_directory_traversal),
            ('ver', self.check_version_based_vulnerabilities)
        ]

        for check_key, check_method in checks:
            try:
                check_method()
            except Exception as e:
                error_message = f"Error during {check_key.upper()} test: {e}"
                self.detailed_logs[check_key].append(error_message)
                self.summaries[check_key] = [f"{check_key.upper()} test: Error"]
                self.success = False
            completed_checks += 1
            self.progress_signal.emit(self.calculate_progress(completed_checks))

        # Append overall success/failure status to summaries
        self.summaries['overall'] = "Scan Successful" if self.success else "Scan Failed"
        
        return self.get_summaries()

    def calculate_progress(self, completed_checks):
        return int((completed_checks / self.num_checks) * 100)

    def check_sql_injection(self):
        payloads = [
            "' OR '1'='1",
            "' AND '1'='1",
            "' OR 'x'='x",
            "' OR 1=1 --",
            "' OR 1=1 /*",
            "' OR 'a'='a",
        ]
        results = ["SQL Injection Test Results:"]
        vulnerabilities_found = False

        for payload in payloads:
            test_url = f"{self.url}?id={payload}"
            try:
                response = requests.get(test_url, timeout=10)
                self.log(f"SQL Injection test URL: {test_url}")
                self.detailed_logs['sql'].append(f"SQL Injection test URL: {test_url}")
                self.log(f"Response Code: {response.status_code}")
                self.detailed_logs['sql'].append(f"Response Code: {response.status_code}")
                self.log(f"Response Time: {response.elapsed.total_seconds()} seconds")
                self.detailed_logs['sql'].append(f"Response Time: {response.elapsed.total_seconds()} seconds")
                self.log(f"Response Length: {len(response.text)} bytes")
                self.detailed_logs['sql'].append(f"Response Length: {len(response.text)} bytes")
                if "error" in response.text.lower() or response.status_code == 500:
                    result = f"Potential SQL Injection vulnerability detected with payload: {payload}"
                    results.append(result)
                    vulnerabilities_found = True
            except requests.RequestException as e:
                error = f"Error during SQL Injection test with payload {payload}: {e}"
                results.append(error)
                self.detailed_logs['sql'].append(error)

        if vulnerabilities_found:
            self.summaries['sql'] = results
        else:
            self.summaries['sql'] = ["No SQL Injection vulnerabilities detected."]

        return "\n".join(self.summaries['sql'])

    def check_xss(self):
        options = Options()
        options.headless = True
        driver = webdriver.Chrome(options=options, service=ChromeService())

        payloads = [
            "<script>alert('XSS')</script>",
            "'\"><img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
        ]
        results = ["XSS Test Results:"]
        vulnerabilities_found = False

        for payload in payloads:
            test_url = f"{self.url}?q={payload}"
            try:
                driver.get(test_url)
                alert = driver.switch_to.alert
                alert.accept()
                result = f"Potential XSS vulnerability detected with payload: {payload}"
                results.append(result)
                vulnerabilities_found = True
            except Exception as e:
                error = f"No alert found for payload {payload}: {e}"
                self.detailed_logs['xss'].append(error)

        driver.quit()

        if vulnerabilities_found:
            self.summaries['xss'] = results
        else:
            self.summaries['xss'] = ["No XSS vulnerabilities detected."]

        return "\n".join(self.summaries['xss'])

    def check_csrf(self):
        results = ["CSRF Test Results:"]
        vulnerabilities_found = False

        try:
            response = requests.get(self.url, timeout=10)
            self.log(f"CSRF test URL: {self.url}")
            self.detailed_logs['csrf'].append(f"CSRF test URL: {self.url}")
            self.log(f"Response Code: {response.status_code}")
            self.detailed_logs['csrf'].append(f"Response Code: {response.status_code}")
            self.log(f"Response Time: {response.elapsed.total_seconds()} seconds")
            self.detailed_logs['csrf'].append(f"Response Time: {response.elapsed.total_seconds()} seconds")
            self.log(f"Response Length: {len(response.text)} bytes")
            self.detailed_logs['csrf'].append(f"Response Length: {len(response.text)} bytes")

            if "csrf" not in response.text.lower():
                result = "Potential CSRF vulnerability detected: No CSRF tokens found."
                results.append(result)
                vulnerabilities_found = True
        except requests.RequestException as e:
            error = f"Error during CSRF test: {e}"
            results.append(error)
            self.detailed_logs['csrf'].append(error)

        if vulnerabilities_found:
            self.summaries['csrf'] = results
        else:
            self.summaries['csrf'] = ["No CSRF vulnerabilities detected."]

        return "\n".join(self.summaries['csrf'])

    def check_directory_traversal(self):
        payloads = [
            "../",
            "..\\",
            "/etc/passwd",
            "C:\\Windows\\System32",
        ]
        results = ["Directory Traversal Test Results:"]
        vulnerabilities_found = False

        for payload in payloads:
            test_url = f"{self.url}/{payload}"
            try:
                response = requests.get(test_url, timeout=10)
                self.log(f"Directory Traversal test URL: {test_url}")
                self.detailed_logs['dir'].append(f"Directory Traversal test URL: {test_url}")
                self.log(f"Response Code: {response.status_code}")
                self.detailed_logs['dir'].append(f"Response Code: {response.status_code}")
                self.log(f"Response Time: {response.elapsed.total_seconds()} seconds")
                self.detailed_logs['dir'].append(f"Response Time: {response.elapsed.total_seconds()} seconds")
                self.log(f"Response Length: {len(response.text)} bytes")
                self.detailed_logs['dir'].append(f"Response Length: {len(response.text)} bytes")
                if response.status_code == 200:
                    result = f"Potential Directory Traversal vulnerability detected with payload: {payload}"
                    results.append(result)
                    vulnerabilities_found = True
            except requests.RequestException as e:
                error = f"Error during Directory Traversal test with payload {payload}: {e}"
                results.append(error)
                self.detailed_logs['dir'].append(error)

        if vulnerabilities_found:
            self.summaries['dir'] = results
        else:
            self.summaries['dir'] = ["No Directory Traversal vulnerabilities detected."]

        return "\n".join(self.summaries['dir'])

    def check_version_based_vulnerabilities(self):
        results = ["Version-based Vulnerability Test Results:"]
        vulnerabilities_found = False

        try:
            response = requests.get(self.url, timeout=10)
            self.log(f"Version-based vulnerability test URL: {self.url}")
            self.detailed_logs['ver'].append(f"Version-based vulnerability test URL: {self.url}")
            self.log(f"Response Code: {response.status_code}")
            self.detailed_logs['ver'].append(f"Response Code: {response.status_code}")
            self.log(f"Response Time: {response.elapsed.total_seconds()} seconds")
            self.detailed_logs['ver'].append(f"Response Time: {response.elapsed.total_seconds()} seconds")
            self.log(f"Response Length: {len(response.text)} bytes")
            self.detailed_logs['ver'].append(f"Response Length: {len(response.text)} bytes")

            soup = BeautifulSoup(response.text, 'html.parser')
            meta_generator = soup.find('meta', {'name': 'generator'})

            if meta_generator:
                generator = meta_generator.get('content', '')
                if generator:
                    self.log(f"Detected generator: {generator}")
                    result = f"Potential version-based vulnerabilities detected: Generator tag found - {generator}"
                    results.append(result)
                    vulnerabilities_found = True

        except requests.RequestException as e:
            error = f"Error during version-based vulnerability test: {e}"
            results.append(error)
            self.detailed_logs['ver'].append(error)

        if vulnerabilities_found:
            self.summaries['ver'] = results
        else:
            self.summaries['ver'] = ["No version-based vulnerabilities detected."]

        return "\n".join(self.summaries['ver'])

    def get_detailed_logs(self):
        return self.detailed_logs

    def get_summaries(self):
        summary_lines = []
        for key in ['sql', 'xss', 'csrf', 'dir', 'ver']:
            summary_lines.append(f"{key.upper()} Summary:\n" + "\n".join(self.summaries[key]))
        
        summary_lines.append(f"Overall Status: {self.summaries['overall']}")
        return "\n\n".join(summary_lines),self.summaries