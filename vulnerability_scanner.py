#vulnerability_scanner

import requests
from bs4 import BeautifulSoup
from PyQt5.QtCore import QObject, pyqtSignal
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service as ChromeService


class VulnerabilityScanner(QObject):
    progress_signal = pyqtSignal(int)

    def __init__(self, url, log_callback):
        super().__init__()
        self.url = url
        self.log = log_callback
        self.num_checks = 5

    def scan(self):
        results = []
        completed_checks = 0

        try:
            results.append(self.check_sql_injection())
        except Exception as e:
            results.append(f"Error during SQL Injection test: {e}")
        completed_checks += 1
        self.progress_signal.emit(self.calculate_progress(completed_checks))

        try:
            results.append(self.check_xss())
        except Exception as e:
            results.append(f"Error during XSS test: {e}")
        completed_checks += 1
        self.progress_signal.emit(self.calculate_progress(completed_checks))

        try:
            results.append(self.check_csrf())
        except Exception as e:
            results.append(f"Error during CSRF test: {e}")
        completed_checks += 1
        self.progress_signal.emit(self.calculate_progress(completed_checks))

        try:
            results.append(self.check_directory_traversal())
        except Exception as e:
            results.append(f"Error during Directory Traversal test: {e}")
        completed_checks += 1
        self.progress_signal.emit(self.calculate_progress(completed_checks))

        try:
            results.append(self.check_version_based_vulnerabilities())
        except Exception as e:
            results.append(f"Error during version-based vulnerability test: {e}")
        completed_checks += 1
        self.progress_signal.emit(self.calculate_progress(completed_checks))

        return "\n".join(results)

    def calculate_progress(self, completed_checks):
        return int((completed_checks / self.num_checks) * 100)

    def check_sql_injection(self):
        payloads = [
            "' OR '1'='1",
            "' AND '1'='1",
            "' OR 'x'='x",
            "' OR 1=1 --",
            "' OR 1=1 /*",
            "' OR 'a'='a",
        ]
        results = []

        for payload in payloads:
            test_url = f"{self.url}?id={payload}"
            try:
                response = requests.get(test_url, timeout=10)
                self.log(f"SQL Injection test URL: {test_url}")
                self.log(f"Response Code: {response.status_code}")
                self.log(f"Response Time: {response.elapsed.total_seconds()} seconds")
                self.log(f"Response Length: {len(response.text)} bytes")
                if "error" in response.text.lower() or response.status_code == 500:
                    results.append(f"Potential SQL Injection vulnerability detected with payload: {payload}")
            except requests.RequestException as e:
                results.append(f"Error during SQL Injection test with payload {payload}: {e}")

        return "\n".join(results)

    def check_xss(self):
        options = Options()
        options.headless = True
        driver = webdriver.Chrome(options=options, service=ChromeService())

        payloads = [
            "<script>alert('XSS')</script>",
            "'\"><img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
        ]
        results = []

        for payload in payloads:
            test_url = f"{self.url}?q={payload}"
            try:
                driver.get(test_url)
                alert = driver.switch_to.alert
                alert.accept()
                results.append(f"Potential XSS vulnerability detected with payload: {payload}")
            except Exception as e:
                self.log(f"No alert found for payload {payload}: {e}")

        driver.quit()
        return "\n".join(results)

    def check_csrf(self):
        results = []

        try:
            response = requests.get(self.url, timeout=10)
            self.log(f"CSRF test URL: {self.url}")
            self.log(f"Response Code: {response.status_code}")
            self.log(f"Response Time: {response.elapsed.total_seconds()} seconds")
            self.log(f"Response Length: {len(response.text)} bytes")

            if "csrf" not in response.text.lower():
                results.append("Potential CSRF vulnerability detected: No CSRF tokens found.")
        except requests.RequestException as e:
            results.append(f"Error during CSRF test: {e}")

        return "\n".join(results)

    def check_directory_traversal(self):
        payloads = [
            "../",
            "..\\",
            "/etc/passwd",
            "C:\\Windows\\System32",
        ]
        results = []

        for payload in payloads:
            test_url = f"{self.url}/{payload}"
            try:
                response = requests.get(test_url, timeout=10)
                self.log(f"Directory Traversal test URL: {test_url}")
                self.log(f"Response Code: {response.status_code}")
                self.log(f"Response Time: {response.elapsed.total_seconds()} seconds")
                self.log(f"Response Length: {len(response.text)} bytes")
                if response.status_code == 200:
                    results.append(f"Potential Directory Traversal vulnerability detected with payload: {payload}")
            except requests.RequestException as e:
                results.append(f"Error during Directory Traversal test with payload {payload}: {e}")

        return "\n".join(results)

    def check_version_based_vulnerabilities(self):
        try:
            response = requests.get(self.url, timeout=10)
            self.log(f"Version-based vulnerability test URL: {self.url}")
            self.log(f"Response Code: {response.status_code}")
            self.log(f"Response Time: {response.elapsed.total_seconds()} seconds")
            self.log(f"Response Length: {len(response.text)} bytes")

            soup = BeautifulSoup(response.text, 'html.parser')
            meta_generator = soup.find('meta', {'name': 'generator'})

            if meta_generator:
                generator = meta_generator.get('content', '')
                if generator:
                    self.log(f"Detected generator: {generator}")
                    return f"Potential version-based vulnerabilities detected: Generator tag found - {generator}"

        except requests.RequestException as e:
            return f"Error during version-based vulnerability test: {e}"

        return "No version-based vulnerabilities detected."
