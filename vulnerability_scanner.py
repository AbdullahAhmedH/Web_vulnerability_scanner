# vulnerability_scanner.py
import requests
from bs4 import BeautifulSoup
from PyQt5.QtCore import QObject, pyqtSignal
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service as ChromeService


class VulnerabilityScanner(QObject):
    progress_signal = pyqtSignal(int)

    def __init__(self, url, log_callback):
        super().__init__()
        self.url = url
        self.log = log_callback
        self.num_checks = 5  # Total number of vulnerability checks

    def scan(self):
        results = []
        completed_checks = 0

        try:
            results.append(self.check_sql_injection())
        except Exception as e:
            results.append(f"Error during SQL Injection test: {e}")
        completed_checks += 1
        self.progress_signal.emit(self.calculate_progress(completed_checks))

        try:
            results.append(self.check_xss())
        except Exception as e:
            results.append(f"Error during XSS test: {e}")
        completed_checks += 1
        self.progress_signal.emit(self.calculate_progress(completed_checks))

        try:
            results.append(self.check_csrf())
        except Exception as e:
            results.append(f"Error during CSRF test: {e}")
        completed_checks += 1
        self.progress_signal.emit(self.calculate_progress(completed_checks))

        try:
            results.append(self.check_directory_traversal())
        except Exception as e:
            results.append(f"Error during Directory Traversal test: {e}")
        completed_checks += 1
        self.progress_signal.emit(self.calculate_progress(completed_checks))

        try:
            results.append(self.check_version_based_vulnerabilities())
        except Exception as e:
            results.append(f"Error during version-based vulnerability test: {e}")
        completed_checks += 1
        self.progress_signal.emit(self.calculate_progress(completed_checks))

        return "\n".join(results)

    def calculate_progress(self, completed_checks):
        return int((completed_checks / self.num_checks) * 100)

    def check_sql_injection(self):
        payloads = [
            "' OR '1'='1",
            "' AND '1'='1",
            "' OR 'x'='x",
            "' OR 1=1 --",
            "' OR 1=1 /*",
            "' OR 'a'='a",
        ]
        results = []

        for payload in payloads:
            test_url = f"{self.url}?id={payload}"
            try:
                response = requests.get(test_url, timeout=10)
                self.log(f"SQL Injection test URL: {test_url}")
                self.log(f"Response Code: {response.status_code}")
                self.log(f"Response Time: {response.elapsed.total_seconds()} seconds")
                self.log(f"Response: {response.text[:100]}")  # Print the first 100 characters of the response

                if response.status_code == 500:
                    results.append("SQL Injection vulnerability detected! (Internal Server Error)")
                elif "syntax error" in response.text.lower() or "sql" in response.text.lower():
                    results.append("SQL Injection vulnerability detected! (SQL error in response)")
                elif "you have an error in your sql syntax" in response.text.lower():
                    results.append("SQL Injection vulnerability detected! (SQL syntax error in response)")
                elif response.elapsed.total_seconds() > 5:
                    results.append("Potential SQL Injection vulnerability detected! (Abnormal response time)")
                else:
                    results.append("No SQL Injection vulnerability detected.")

            except requests.exceptions.RequestException as e:
                results.append(f"Error during SQL Injection test with payload '{payload}': {e}")

        return "\n".join(results)

    def check_xss(self):
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src='x' onerror='alert(\"XSS\")'>",
            "<svg/onload=alert(1)>",
            "<iframe src='javascript:alert(1)'></iframe>",
            "<body onload=alert('XSS')>",
            "<input type='text' value='><script>alert(1)</script>'>",
            "<a href='javascript:alert(1)'>Click me</a>",
            "javascript:alert('XSS')",
        ]

        # Option 1: Using simple requests
        results = self.check_xss_with_requests(payloads)

        # Option 2: Using Selenium
        results += self.check_xss_with_selenium(self.url, payloads)
        return results

    def check_xss_with_requests(self, payloads):
        results = []
        for payload in payloads:
            test_url = f"{self.url}?q={payload}"
            try:
                response = requests.get(test_url)
                self.log(f"XSS test URL: {test_url}")
                if payload in response.text:
                    results.append(f"XSS vulnerability detected with payload: {payload}")
                else:
                    results.append(f"No XSS detected with payload: {payload}")
            except Exception as e:
                self.log(f"Error during XSS test with payload '{payload}': {e}")
                results.append(f"Error during XSS test with payload '{payload}': {e}")
        return results

    def check_xss_with_selenium(self, url, payloads):
        chrome_options = Options()
        chrome_options.add_argument("--headless")
        service = ChromeService(executable_path='/path/to/chromedriver')  # Update the path

        driver = webdriver.Chrome(service=service, options=chrome_options)
        try:
            results = []
            for payload in payloads:
                test_url = f"{url}?q={payload}"
                driver.get(test_url)
                self.log(f"Selenium XSS test URL: {test_url}")
                if payload in driver.page_source:
                    results.append(f"XSS vulnerability detected with payload: {payload}")
                else:
                    driver.execute_script(f"var test = '{payload}';")
                    if driver.execute_script("return document.body.innerHTML.includes(test);"):
                        results.append(f"XSS vulnerability detected with payload: {payload}")
            return results
        finally:
            driver.quit()

    def check_csrf(self):
        try:
            # Fetch the page content
            response = requests.get(self.url)
            self.log(f"CSRF test URL: {self.url}")
            soup = BeautifulSoup(response.text, 'html.parser')

            # Check for CSRF tokens in forms
            csrf_token_present = False
            forms = soup.find_all('form')
            for form in forms:
                inputs = form.find_all('input')
                for input_tag in inputs:
                    if 'csrf' in input_tag.get('name', '').lower():
                        csrf_token_present = True
                        break
                if csrf_token_present:
                    break
            
            # Check for SameSite cookie attribute
            same_site_cookie_check = self.check_samesite_cookie(self.url)
            
            if csrf_token_present:
                csrf_status = "CSRF token detected in forms."
            else:
                csrf_status = "No CSRF token found in forms."

            csrf_status += f" SameSite Cookie Check: {same_site_cookie_check}"

            return csrf_status
        except Exception as e:
            self.log(f"Error during CSRF test: {e}")
            return f"Error during CSRF test: {e}"

    def check_samesite_cookie(self, url):
        try:
            response = requests.get(url, headers={'Referer': url})
            cookies = response.cookies
            if cookies:
                same_site_found = False
                for cookie in cookies:
                    # Get the 'Set-Cookie' header from the response to check 'SameSite'
                    if 'Set-Cookie' in response.headers:
                        cookie_headers = response.headers['Set-Cookie']
                        if 'SameSite=' in cookie_headers:
                            same_site_found = True
                            same_site_value = cookie_headers.split('SameSite=')[1].split(';')[0]
                            self.log(f"SameSite attribute present: {same_site_value}")
                            return f"SameSite attribute present: {same_site_value}"
                if not same_site_found:
                    return "SameSite attribute not present."
            else:
                return "No cookies found."
        except Exception as e:
            self.log(f"Error during SameSite cookie check: {e}")
            return f"Error during SameSite cookie check: {e}"

    def check_directory_traversal(self):
        payloads = [
            "../../../../etc/passwd",
            "../../../etc/passwd",
            "../../../../../../etc/passwd",
            "..%2F..%2F..%2F..%2Fetc%2Fpasswd",  # URL encoding
            "..%5C..%5C..%5C..%5Cetc%5Cpasswd",  # Windows-style encoding
            "..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd"
        ]
        
        results = []
        for payload in payloads:
            test_url = f"{self.url}/{payload}"
            try:
                response = requests.get(test_url, timeout=10)
                self.log(f"Directory Traversal test URL: {test_url}")
                self.log(f"Response Code: {response.status_code}")
                self.log(f"Response: {response.text[:100]}")  # Print the first 100 characters of the response
                
                # Check for known sensitive content
                if "root:x" in response.text or "/etc/passwd" in response.text:
                    results.append(f"Directory Traversal vulnerability detected with payload: {payload}")
                elif response.status_code == 200 and len(response.text) > 1000:
                    # Example check for unusually large responses
                    results.append(f"Potential Directory Traversal vulnerability detected (unusually large response) with payload: {payload}")
                else:
                    results.append(f"No Directory Traversal detected with payload: {payload}")
            except Exception as e:
                results.append(f"Error during Directory Traversal test with payload '{payload}': {e}")
        
        return "\n".join(results)

    def check_version_based_vulnerabilities(self):
        vulnerable_versions = {
            "Apache": ["2.2.3", "2.2.22", "2.4.1"],
            "nginx": ["1.0.0", "1.2.0"],
            "IIS": ["6.0", "7.0"],
            "PHP": ["5.2.0", "5.3.0"],
            # Add more software and versions as needed
        }
        
        try:
            response = requests.get(self.url)
            headers = response.headers
            server_header = headers.get("Server", "").strip()
            x_powered_by = headers.get("X-Powered-By", "").strip()
            
            self.log(f"Version-based vulnerability test URL: {self.url}")
            self.log(f"Response Headers: {headers}")

            detected_vulnerabilities = []

            # Check Server header
            for software, versions in vulnerable_versions.items():
                if software in server_header:
                    for version in versions:
                        if version in server_header:
                            detected_vulnerabilities.append(f"{software} version {version} detected as vulnerable")

            # Check X-Powered-By header
            for software, versions in vulnerable_versions.items():
                if software in x_powered_by:
                    for version in versions:
                        if version in x_powered_by:
                            detected_vulnerabilities.append(f"{software} version {version} detected as vulnerable")

            if detected_vulnerabilities:
                return "\n".join(detected_vulnerabilities)
            return "No version-based vulnerabilities detected."

        except requests.RequestException as e:
            self.log(f"Error during version-based vulnerability test: {e}")
            return f"Error during version-based vulnerability test: {e}"
