import os
import sys

import requests
import validators
from PyQt5 import QtGui
from PyQt5.QtCore import QThread, pyqtSignal
from PyQt5.QtWidgets import QApplication, QMainWindow, QStackedWidget, QWidget

from loading_page import Ui_loading_page
from results import Ui_results
from url_page import Ui_url_page


class ScanThread(QThread):
    log_message = pyqtSignal(str)
    scan_completed = pyqtSignal(str)

    def __init__(self, url):
        super().__init__()
        self.url = url

    def run(self):
        results = []
        try:
            results.append(self.check_sql_injection())
        except Exception as e:
            results.append(f"Error during SQL Injection test: {e}")

        try:
            results.append(self.check_xss())
        except Exception as e:
            results.append(f"Error during XSS test: {e}")

        try:
            results.append(self.check_csrf())
        except Exception as e:
            results.append(f"Error during CSRF test: {e}")

        try:
            results.append(self.check_directory_traversal())
        except Exception as e:
            results.append(f"Error during Directory Traversal test: {e}")

        try:
            results.append(self.check_version_based_vulnerabilities())
        except Exception as e:
            results.append(f"Error during version-based vulnerability test: {e}")

        self.scan_completed.emit("\n".join(results))

    def log(self, message):
        self.log_message.emit(message)

    def check_sql_injection(self):
        payload = "' OR '1'='1"
        test_url = f"{self.url}?id={payload}"
        try:
            response = requests.get(test_url)
            self.log(f"SQL Injection test URL: {test_url}")
            self.log(f"Response: {response.text[:100]}")  # Print the first 100 characters of the response
            if "error" not in response.text.lower():
                return "SQL Injection vulnerability detected!"
            return "No SQL Injection vulnerability detected."
        except Exception as e:
            return f"Error during SQL Injection test: {e}"

    def check_xss(self):
        payload = "<script>alert('XSS')</script>"
        test_url = f"{self.url}?q={payload}"
        try:
            response = requests.get(test_url)
            self.log(f"XSS test URL: {test_url}")
            self.log(f"Response: {response.text[:100]}")  # Print the first 100 characters of the response
            if payload in response.text:
                return "XSS vulnerability detected!"
            return "No XSS vulnerability detected."
        except Exception as e:
            return f"Error during XSS test: {e}"

    def check_csrf(self):
        try:
            response = requests.get(self.url)
            self.log(f"CSRF test URL: {self.url}")
            self.log(f"Response: {response.text[:100]}")  # Print the first 100 characters of the response
            if "csrf_token" not in response.text.lower():
                return "CSRF vulnerability found!"
            return "No CSRF vulnerability detected."
        except Exception as e:
            return f"Error during CSRF test: {e}"

    def check_directory_traversal(self):
        payload = "../../../../etc/passwd"
        test_url = f"{self.url}/{payload}"
        try:
            response = requests.get(test_url)
            self.log(f"Directory Traversal test URL: {test_url}")
            self.log(f"Response: {response.text[:100]}")  # Print the first 100 characters of the response
            if "root:x" in response.text:
                return "Directory Traversal vulnerability detected!"
            return "No Directory Traversal vulnerability detected."
        except Exception as e:
            return f"Error during Directory Traversal test: {e}"

    def check_version_based_vulnerabilities(self):
        try:
            response = requests.get(self.url)
            self.log(f"Version-based vulnerability test URL: {self.url}")
            self.log(f"Response Headers: {response.headers}")  # Print the response headers
            if "Server:" in response.headers:
                server_header = response.headers["Server"]
                if "Apache/2.2.3" in server_header:
                    return "Version-based vulnerability detected: Apache/2.2.3"
            return "No version-based vulnerabilities detected."
        except Exception as e:
            return f"Error during version-based vulnerability test: {e}"


class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.setWindowTitle("Web Vulnerability Scanner")
        self.setMinimumSize(482, 360)

        # Setup URL Input Widget
        self.url_input_screen = Ui_url_page()
        self.url_input_widget = QWidget()
        self.url_input_screen.setupUi(self.url_input_widget)
        self.url_input_widget.setFixedSize(482, 360)

        # Setup Loading Widget
        self.loading_page = Ui_loading_page()
        self.loading_widget = QWidget()
        self.loading_page.setupUi(self.loading_widget)
        self.loading_widget.setFixedSize(482, 360)

        # Setup Results Widget
        self.results_screen = Ui_results()
        self.results_widget = QWidget()
        self.results_screen.setupUi(self.results_widget)
        self.results_widget.setFixedSize(482, 360)

        # Setup stacked widget
        self.stacked_widget = QStackedWidget()
        self.stacked_widget.addWidget(self.url_input_widget)
        self.stacked_widget.addWidget(self.loading_widget)
        self.stacked_widget.addWidget(self.results_widget)
        self.setCentralWidget(self.stacked_widget)

        # Connect signals and slots
        self.url_input_screen.pushButton.clicked.connect(self.start_scan)
        self.loading_page.pushButton.setEnabled(False)
        self.loading_page.pushButton.clicked.connect(self.show_results)
        self.results_screen.pushButton_2.clicked.connect(self.restart_application)

    def start_scan(self):
        url = self.url_input_screen.lineEdit.text()
        if self.validate_url(url):
            self.stacked_widget.setCurrentWidget(self.loading_widget)
            self.scan_thread = ScanThread(url)
            self.scan_thread.log_message.connect(self.update_log_view)
            self.scan_thread.scan_completed.connect(self.scan_complete_handler)
            self.scan_thread.start()
        else:
            self.url_input_screen.label_2.setText("Invalid URL. Please try again.")

    def validate_url(self, url):
        if not url.startswith(('http://', 'https://')):
            url = 'http://' + url
        
        if validators.url(url):
            try:
                response = requests.head(url, allow_redirects=True)
                return response.status_code < 400
            except requests.RequestException:
                return False
        return False

    def update_log_view(self, message):
        current_model = self.loading_page.listView.model()
        if current_model is None:
            current_model = QtGui.QStandardItemModel()
            self.loading_page.listView.setModel(current_model)
        current_model.appendRow(QtGui.QStandardItem(message))

    def scan_complete_handler(self, result):
        self.loading_page.pushButton.setEnabled(True)
        _, detailed_results = self.summarize_results(result)
        self.results_screen.listView.setModel(self.create_list_model(detailed_results))

    def summarize_results(self, results):
        lines = results.split("\n")
        summary = []
        detailed_results = []
        for line in lines:
            detailed_results.append(line)
            if "vulnerability detected" in line:
                summary.append(line)
        return "\n".join(summary), "\n".join(detailed_results)

    def create_list_model(self, result):
        model = QtGui.QStandardItemModel()
        items = result.split('\n')
        for item in items:
            model.appendRow(QtGui.QStandardItem(item))
        return model

    def restart_application(self): 
        QApplication.quit()
        os.execl(sys.executable, "python", "main.py")

    def show_results(self):
        self.stacked_widget.setCurrentWidget(self.results_widget)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
