import os
import sys
from textwrap import wrap

import requests
import validators
from PyQt5 import QtGui
from PyQt5.QtCore import QThread, pyqtSignal, pyqtSlot
from PyQt5.QtWidgets import (QApplication, QFileDialog, QMainWindow,
                             QStackedWidget, QWidget)
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas

from loading_page import Ui_loading_page
from results import Ui_results
from url_page import Ui_url_page
from vulnerability_scanner import VulnerabilityScanner


class ScanThread(QThread):
    log_message = pyqtSignal(str)
    scan_completed = pyqtSignal()
    progress_signal = pyqtSignal(int)

    def __init__(self, url):
        super().__init__()
        self.url = url
        self.summaries = ""
        self.summaries_dict = {}
        self.detailed_logs = {}

    def run(self):
        scanner = VulnerabilityScanner(self.url, self.log)
        scanner.progress_signal.connect(self.update_progress)
        results = scanner.scan()
        self.summaries, self.summaries_dict = scanner.get_summaries()
        self.detailed_logs = scanner.get_detailed_logs()
        self.scan_completed.emit()

    def log(self, message):
        self.log_message.emit(message)

    @pyqtSlot(int)
    def update_progress(self, value):
        self.progress_signal.emit(value)


class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.setWindowTitle("Web Vulnerability Scanner")
        self.setMinimumSize(482, 360)

        # Setup URL Input Widget
        self.url_input_screen = Ui_url_page()
        self.url_input_widget = QWidget()
        self.url_input_screen.setupUi(self.url_input_widget)
        self.url_input_widget.setFixedSize(482, 360)

        # Setup Loading Widget
        self.loading_page = Ui_loading_page()
        self.loading_widget = QWidget()
        self.loading_page.setupUi(self.loading_widget)
        self.loading_widget.setFixedSize(482, 360)

        # Setup Results Widget
        self.results_screen = Ui_results()
        self.results_widget = QWidget()
        self.results_screen.setupUi(self.results_widget)
        self.results_widget.setFixedSize(482, 360)

        # Setup stacked widget
        self.stacked_widget = QStackedWidget()
        self.stacked_widget.addWidget(self.url_input_widget)
        self.stacked_widget.addWidget(self.loading_widget)
        self.stacked_widget.addWidget(self.results_widget)
        self.setCentralWidget(self.stacked_widget)

        # Connect signals and slots
        self.url_input_screen.pushButton.clicked.connect(self.start_scan)
        self.loading_page.pushButton.setEnabled(False)
        self.loading_page.pushButton.clicked.connect(self.show_results)
        self.results_screen.pushButton_2.clicked.connect(self.restart_application)
        self.results_screen.pushButton_back.clicked.connect(self.go_back_to_loading_page)
        self.results_screen.pushButton.clicked.connect(self.download_pdf)

        self.url = ""
        self.summaries_dict = {}
        self.detailed_logs = {}

    def start_scan(self):
        self.url = self.url_input_screen.lineEdit.text()
        if self.validate_url(self.url):
            self.stacked_widget.setCurrentWidget(self.loading_widget)
            if not self.url.startswith(('http://', 'https://')):
                self.url = 'http://' + self.url
            self.scan_thread = ScanThread(self.url)
            self.scan_thread.log_message.connect(self.update_log_view)
            self.scan_thread.scan_completed.connect(self.scan_complete_handler)
            self.scan_thread.progress_signal.connect(self.update_progress_bar)
            self.scan_thread.start()
        else:
            self.url_input_screen.label_2.setText("Invalid URL. Please try again.")

    def validate_url(self, url):
        if not url.startswith(('http://', 'https://')):
            url = 'http://' + url

        if validators.url(url):
            try:
                response = requests.head(url, allow_redirects=True)
                return response.status_code < 400
            except requests.RequestException:
                return False
        return False

    def update_log_view(self, message):
        current_model = self.loading_page.listView.model()
        if current_model is None:
            current_model = QtGui.QStandardItemModel()
            self.loading_page.listView.setModel(current_model)
        current_model.appendRow(QtGui.QStandardItem(message))

    def scan_complete_handler(self):
        self.loading_page.pushButton.setEnabled(True)
        self.summaries_dict = self.scan_thread.summaries_dict
        self.detailed_logs = self.scan_thread.detailed_logs
        summary_text = "\n".join(f"{k}: {v}" for k, v in self.summaries_dict.items())
        self.results_screen.listView.setModel(self.create_list_model(summary_text))

    def update_progress_bar(self, value):
        self.loading_page.progressBar.setValue(value)

    def create_list_model(self, result):
        model = QtGui.QStandardItemModel()
        items = result.split('\n')
        for item in items:
            model.appendRow(QtGui.QStandardItem(item))
        return model

    def restart_application(self):
        QApplication.quit()
        os.execl(sys.executable, "python", "main.py")

    def show_results(self):
        self.stacked_widget.setCurrentWidget(self.results_widget)

    def go_back_to_loading_page(self):
        self.stacked_widget.setCurrentWidget(self.loading_widget)

    def download_pdf(self):
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getSaveFileName(self, "Save PDF", "", "PDF Files (*.pdf);;All Files (*)", options=options)
        if file_path:
            self.create_pdf(file_path)

    def create_pdf(self, file_path):
        c = canvas.Canvas(file_path, pagesize=letter)
        width, height = letter

        c.setFont("Helvetica", 12)
        y = height - 40

        # Write URL at the beginning
        c.drawString(40, y, f"URL: {self.url}")
        y -= 20

        # Define margins
        left_margin = 40
        line_height = 15
        max_line_length = 100  # Max characters per line before wrapping

        # Function to draw text and handle page breaks
        def draw_text(lines, c, y, left_margin, line_height, height):
            for line in lines:
                wrapped_lines = wrap(line, max_line_length)
                for wrapped_line in wrapped_lines:
                    if y < 40:
                        c.showPage()
                        c.setFont("Helvetica", 12)
                        y = height - 40
                    c.drawString(left_margin, y, wrapped_line)
                    y -= line_height
            return y

        # Write Scan Results Summary and Detailed Logs
        for key in ['sql', 'xss', 'csrf', 'dir', 'ver']:
            # Write summary for each key
            summary_title = f"{key.upper()} Summary:"
            c.drawString(left_margin, y, summary_title)
            y -= line_height
            y = draw_text(self.summaries_dict.get(key, []), c, y, left_margin, line_height, height)

            y -= line_height  # Add extra space between summary and detailed logs

            # Write detailed logs for each key
            log_title = f"{key.upper()} Logs:"
            c.drawString(left_margin, y, log_title)
            y -= line_height
            y = draw_text(self.detailed_logs.get(key, []), c, y, left_margin, line_height, height)

            y -= line_height  # Add extra space between sections

        # Write overall status at the end
        c.drawString(left_margin, y, "Overall Status:")
        y -= line_height
        y = draw_text([self.summaries_dict.get('overall', '')], c, y, left_margin, line_height, height)

        c.save()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
